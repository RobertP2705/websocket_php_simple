<!DOCTYPE html>
<html>
<head>
    <title>Multi-Table WebSocket Project - Technical Guide</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .warning {
            background: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }
        .info {
            background: #d1ecf1;
            padding: 15px;
            border-left: 4px solid #17a2b8;
            margin: 20px 0;
        }
        .step {
            background: #e8f5e8;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        .code-example {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            margin: 15px 0;
        }
        .code-example .header {
            background: #e9ecef;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            font-weight: bold;
        }
        .code-example .content {
            padding: 15px;
        }
    </style>
</head>
<body>
    <h1>Multi-Table WebSocket Project - Technical Guide</h1>

    <h2>System Overview</h2>
    <p>This project implements a <strong>table-agnostic</strong> WebSocket server in PHP for real-time database change monitoring across multiple tables. The server automatically discovers all tables in the database and allows clients to subscribe to specific tables they're interested in. This provides a scalable foundation for monitoring any number of tables simultaneously.</p>

    <div class="highlight">
        <strong>Key Features:</strong>
        <ul>
            <li><strong>Table-Agnostic:</strong> Automatically discovers and monitors all database tables</li>
            <li><strong>Client Subscriptions:</strong> Clients can subscribe/unsubscribe to specific tables</li>
            <li><strong>Targeted Broadcasting:</strong> Only sends updates to clients subscribed to changed tables</li>
            <li><strong>Efficient Monitoring:</strong> Only checks tables that have active subscribers</li>
            <li><strong>Multi-Client Support:</strong> Different clients can monitor different tables simultaneously</li>
            <li><strong>Callback System:</strong> Custom logic for both server and client-side processing</li>
        </ul>
    </div>

    <div class="info">
        <strong>Architecture Benefits:</strong>
        <ul>
            <li><strong>Scalability:</strong> Can handle hundreds of tables and clients efficiently</li>
            <li><strong>Flexibility:</strong> Clients only receive data they're interested in</li>
            <li><strong>Performance:</strong> Reduces unnecessary network traffic and processing</li>
            <li><strong>Maintainability:</strong> No need to modify server code when adding new tables</li>
        </ul>
    </div>

    <h2>File Structure</h2>
    <ul>
        <li><strong>server.php</strong> - Table-agnostic WebSocket server with subscription management</li>
        <li><strong>websockets.php</strong> - Core WebSocket protocol implementation</li>
        <li><strong>config.php</strong> - Database configuration and shared PDO connection</li>
        <li><strong>client.php</strong> - Multi-table Web client with subscription interface</li>
        <li><strong>users.php</strong> - User/session management for WebSocket connections</li>
        <li><strong>database_operations.php</strong> - Handles AJAX CRUD operations from the client</li>
        <li><strong>.htaccess</strong> - Apache configuration with WebSocket proxy</li>
    </ul>

    <h2>Data Flow</h2>
    <ol>
        <li><strong>Server Startup:</strong> Server discovers all tables in the database</li>
        <li><strong>Client Connection:</strong> Client connects and receives list of available tables</li>
        <li><strong>Table Subscription:</strong> Client subscribes to specific tables of interest</li>
        <li><strong>Change Monitoring:</strong> Server polls subscribed tables every 2 seconds</li>
        <li><strong>Targeted Broadcasting:</strong> When changes detected, only subscribed clients receive updates</li>
        <li><strong>CRUD Operations:</strong> Performed via <code>database_operations.php</code> (AJAX)</li>
    </ol>

    <h2>Server Implementation</h2>
    <h3>DatabaseChangeServer Class - Table-Agnostic Design</h3>
    <p>The server is designed to be completely table-agnostic and supports multiple concurrent subscriptions:</p>
    
    <pre><code>class DatabaseChangeServer extends WebSocketServer {
    // Track table hashes and client subscriptions
    private $tableHashes = []; // [tableName => hash]
    private $clientSubscriptions = []; // [userId => [table1, table2, ...]]
    private $monitoredTables = []; // [tableName => lastCheckTime]
    
    public function __construct($address, $port) {
        parent::__construct($address, $port);
        $this->pdo = getPDO();
        $this->discoverTables(); // Auto-discover all tables
    }
    
    // Client message handling with subscription support
    function process($user, $message) {
        switch ($data['action']) {
            case 'subscribe':
                $this->handleSubscribe($user, $data);
                break;
            case 'unsubscribe':
                $this->handleUnsubscribe($user, $data);
                break;
            case 'get_tables':
                $this->sendAvailableTables($user);
                break;
            // ... other actions
        }
    }
    
    // Only check tables with active subscribers
    private function checkForDatabaseChanges() {
        $activeTables = [];
        foreach ($this->clientSubscriptions as $subscriptions) {
            foreach ($subscriptions as $table) {
                $activeTables[$table] = true;
            }
        }
        
        foreach (array_keys($activeTables) as $tableName) {
            $this->checkTableForChanges($tableName);
        }
    }
    
    // Targeted broadcasting - only to subscribed clients
    private function broadcastTableChange($tableName, $records) {
        foreach ($this->users as $user) {
            if (isset($this->clientSubscriptions[$user->id]) && 
                in_array($tableName, $this->clientSubscriptions[$user->id])) {
                $this->send($user, $message);
            }
        }
    }
}
</code></pre>

    <h2>Client Implementation</h2>
    <h3>Subscription-Based Client</h3>
    <p>The client now supports subscribing to multiple tables and displays them in a grid layout:</p>
    
    <pre><code>// Connect and get available tables
const socket = new WebSocket("wss://your-server/websocket");

socket.onopen = function() {
    // Request available tables
    socket.send(JSON.stringify({ action: 'get_tables' }));
};

// Subscribe to specific tables
function subscribeToTable(tableName) {
    socket.send(JSON.stringify({ 
        action: 'subscribe', 
        table: tableName 
    }));
}

// Handle table-specific updates
socket.onmessage = function(msg) {
    const data = JSON.parse(msg.data);
    switch(data.action) {
        case 'table_changed':
            updateTableDisplay(data.table, data.data);
            break;
        case 'subscribed':
            console.log('Subscribed to:', data.table);
            break;
    }
};
</code></pre>

    <h2>WebSocket Protocol</h2>
    <h3>Client to Server Messages</h3>
    <ul>
        <li><code>{ "action": "subscribe", "table": "table_name" }</code> - Subscribe to table updates</li>
        <li><code>{ "action": "unsubscribe", "table": "table_name" }</code> - Unsubscribe from table updates</li>
        <li><code>{ "action": "get_tables" }</code> - Get list of available tables</li>
        <li><code>{ "action": "get_table_data", "table": "table_name" }</code> - Get current table data</li>
        <li><code>{ "action": "ping" }</code> - Keep-alive ping</li>
    </ul>

    <h3>Server to Client Messages</h3>
    <ul>
        <li><code>{ "action": "welcome", "available_tables": [...] }</code> - Connection welcome with table list</li>
        <li><code>{ "action": "subscribed", "table": "table_name", "subscriptions": [...] }</code> - Subscription confirmation</li>
        <li><code>{ "action": "table_changed", "table": "table_name", "data": [...], "timestamp": 1234567890 }</code> - Table update</li>
        <li><code>{ "action": "table_data", "table": "table_name", "data": [...] }</code> - Current table data</li>
        <li><code>{ "action": "available_tables", "tables": [...] }</code> - List of available tables</li>
        <li><code>{ "action": "error", "message": "error description" }</code> - Error message</li>
    </ul>

    <h2>Database Usage</h2>
    <h3>Automatic Table Discovery</h3>
    <p>The server automatically discovers all tables using SQL Server's INFORMATION_SCHEMA:</p>
    <pre><code>// In discoverTables()
$query = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";
$sql = $this->pdo->prepare($query);
$sql->execute();
$tables = $sql->fetchAll(PDO::FETCH_COLUMN);
</code></pre>

    <h3>Shared PDO Connection</h3>
    <p>The system uses a shared PDO connection defined in <code>config.php</code>. Both the server and CRUD operations use the same connection:</p>
    <pre><code>// In config.php
function getPDO() {
    static $pdo = null;
    
    if ($pdo === null) {
        $pdo = new PDO("odbc:Driver=FreeTDS; Server=" . DB_HOST . "; Port=" . DB_PORT . "; Database=" . DB_NAME . "; UID=" . DB_USER . "; PWD=" . DB_PASS . ";", 
                      null, null, 
                      array(PDO::ATTR_TIMEOUT => 5, PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION));
    }
    
    return $pdo;
}
</code></pre>

    <h2>Connecting Your Custom Tables - Complete Guide</h2>
    
    <div class="info">
        <strong>Overview:</strong> This guide will walk you through the complete process of connecting your own database tables to the WebSocket backend and making them responsive to real-time changes. The system uses a <strong>client-specific, subscription-based approach</strong> where each client is configured to monitor specific tables.
    </div>

    <h3>Step 1: Understanding the Client-Specific Approach</h3>
    <div class="step">
        <strong>How It Works:</strong> 
        <ul>
            <li>The server is <strong>table-agnostic</strong> and does not discover all tables at startup</li>
            <li>Each client is <strong>configured to monitor specific tables</strong> based on its purpose</li>
            <li>The server only monitors tables that have <strong>active client subscriptions</strong></li>
            <li>When a client connects, it automatically subscribes to its configured tables</li>
            <li>When all clients unsubscribe from a table, the server stops monitoring it</li>
        </ul>
    </div>

    <h3>Step 2: Creating Your Custom Table</h3>
    <div class="code-example">
        <div class="header">Example: Creating a Custom Table</div>
        <div class="content">
            <p>Let's say you want to monitor a <code>conductors</code> table:</p>
            <pre><code>-- Create your custom table
CREATE TABLE conductors (
    id INT IDENTITY(1,1) PRIMARY KEY,
    name NVARCHAR(255) NOT NULL,
    type NVARCHAR(100),
    size NVARCHAR(50),
    material NVARCHAR(100),
    resistance DECIMAL(10,4),
    created_at DATETIME DEFAULT GETDATE(),
    updated_at DATETIME DEFAULT GETDATE()
);

-- Insert some sample data
INSERT INTO conductors (name, type, size, material, resistance) VALUES
('Conductor-001', 'Power', '4/0 AWG', 'Copper', 0.0001),
('Conductor-002', 'Control', '12 AWG', 'Aluminum', 0.0016),
('Conductor-003', 'Signal', '18 AWG', 'Copper', 0.0065);</code></pre>
        </div>
    </div>

    <h3>Step 3: Creating Client-Specific Applications</h3>
    
    <h4>3.1 Client Configuration Pattern</h4>
    <div class="code-example">
        <div class="header">Client Configuration Structure</div>
        <div class="content">
            <pre><code>// Client-specific configuration
const CLIENT_CONFIG = {
    name: 'YourClientName',
    targetTable: 'your_table_name',
    serverUrl: 'wss://your-domain.com/websocket'
};

// Auto-subscribe on connection
function subscribeToTargetTable() {
    if (socket && isConnected) {
        socket.send(JSON.stringify({ 
            action: 'subscribe', 
            table: CLIENT_CONFIG.targetTable 
        }));
    }
}</code></pre>
        </div>
    </div>

    <h4>3.2 Example: Client1.php (Items Monitor)</h4>
    <div class="code-example">
        <div class="header">Client1.php - Configured for 'items' table</div>
        <div class="content">
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Items Table Monitor - Client 1&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;📊 Items Table Monitor - Client 1&lt;/h1&gt;
        
        &lt;div class="client-info"&gt;
            &lt;h3&gt;Client Configuration&lt;/h3&gt;
            &lt;p&gt;&lt;strong&gt;Purpose:&lt;/strong&gt; Monitor the 'items' table for real-time updates&lt;/p&gt;
            &lt;p&gt;&lt;strong&gt;Target Table:&lt;/strong&gt; &lt;code&gt;items&lt;/code&gt;&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;div id="status"&gt;Connecting...&lt;/div&gt;
        &lt;div id="items-table"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Client-specific configuration
        const CLIENT_CONFIG = {
            name: 'Client1',
            targetTable: 'items',
            serverUrl: 'wss://your-domain.com/websocket'
        };

        function connect() {
            socket = new WebSocket(CLIENT_CONFIG.serverUrl);
            
            socket.onopen = function() {
                // Automatically subscribe to configured table
                subscribeToTargetTable();
            };
            
            socket.onmessage = function(msg) {
                const data = JSON.parse(msg.data);
                if (data.action === 'table_changed' && data.table === CLIENT_CONFIG.targetTable) {
                    updateItemsTable(data.data);
                }
            };
        }

        function subscribeToTargetTable() {
            socket.send(JSON.stringify({ 
                action: 'subscribe', 
                table: CLIENT_CONFIG.targetTable 
            }));
        }

        // Auto-connect when page loads
        window.onload = connect;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
        </div>
    </div>

    <h4>3.3 Example: Client2.php (Conductors Monitor)</h4>
    <div class="code-example">
        <div class="header">Client2.php - Configured for 'conductors' table</div>
        <div class="content">
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Conductors Table Monitor - Client 2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;⚡ Conductors Table Monitor - Client 2&lt;/h1&gt;
        
        &lt;div class="client-info"&gt;
            &lt;h3&gt;Client Configuration&lt;/h3&gt;
            &lt;p&gt;&lt;strong&gt;Purpose:&lt;/strong&gt; Monitor the 'conductors' table for real-time updates&lt;/p&gt;
            &lt;p&gt;&lt;strong&gt;Target Table:&lt;/strong&gt; &lt;code&gt;conductors&lt;/code&gt;&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;div id="status"&gt;Connecting...&lt;/div&gt;
        &lt;div id="conductors-table"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Client-specific configuration
        const CLIENT_CONFIG = {
            name: 'Client2',
            targetTable: 'conductors',
            serverUrl: 'wss://your-domain.com/websocket'
        };

        function connect() {
            socket = new WebSocket(CLIENT_CONFIG.serverUrl);
            
            socket.onopen = function() {
                // Automatically subscribe to configured table
                subscribeToTargetTable();
            };
            
            socket.onmessage = function(msg) {
                const data = JSON.parse(msg.data);
                if (data.action === 'table_changed' && data.table === CLIENT_CONFIG.targetTable) {
                    updateConductorsTable(data.data);
                }
            };
        }

        function subscribeToTargetTable() {
            socket.send(JSON.stringify({ 
                action: 'subscribe', 
                table: CLIENT_CONFIG.targetTable 
            }));
        }

        // Auto-connect when page loads
        window.onload = connect;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
        </div>
    </div>

    <h3>Step 4: Server Behavior</h3>
    <div class="step">
        <strong>Server Startup:</strong> The server starts without monitoring any tables and waits for client subscriptions.
    </div>

    <p>When you start the server, you'll see:</p>
    <pre><code>Server started - waiting for client subscriptions</code></pre>

    <div class="step">
        <strong>Client Connection Flow:</strong>
        <ol>
            <li>Client connects to server</li>
            <li>Client automatically subscribes to its configured table</li>
            <li>Server validates table exists in database</li>
            <li>Server starts monitoring the table (if not already monitoring)</li>
            <li>Server sends current table data to client</li>
            <li>Server continues monitoring and sends updates when changes detected</li>
        </ol>
    </div>

    <p>Server output examples:</p>
    <pre><code>User u123456 subscribed to table 'items' - now monitoring this table
User u789012 subscribed to table 'conductors' - now monitoring this table
Change detected in table 'items', broadcasting to subscribers
Change detected in table 'conductors', broadcasting to subscribers</code></pre>

    <h3>Step 5: Integration with Existing Websites</h3>
    
    <h4>5.1 Embedding in Existing Pages</h4>
    <div class="code-example">
        <div class="header">Integrating Table Monitor into Existing Website</div>
        <div class="content">
            <pre><code>&lt;!-- Add this to your existing HTML page --&gt;
&lt;div id="table-monitor"&gt;
    &lt;h3&gt;Real-time Table Updates&lt;/h3&gt;
    &lt;div id="status"&gt;Connecting...&lt;/div&gt;
    &lt;div id="table-data"&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
// Configuration for this specific page
const TABLE_CONFIG = {
    targetTable: 'your_table_name',
    serverUrl: 'wss://your-domain.com/websocket'
};

// WebSocket connection
let socket = null;

function initTableMonitor() {
    socket = new WebSocket(TABLE_CONFIG.serverUrl);
    
    socket.onopen = function() {
        document.getElementById('status').textContent = 'Connected';
        // Subscribe to the table
        socket.send(JSON.stringify({
            action: 'subscribe',
            table: TABLE_CONFIG.targetTable
        }));
    };
    
    socket.onmessage = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.action === 'table_changed' && data.table === TABLE_CONFIG.targetTable) {
            updateTableDisplay(data.data);
        }
    };
}

function updateTableDisplay(data) {
    const container = document.getElementById('table-data');
    // Update your existing page with the new data
    // This integrates seamlessly with your current UI
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', initTableMonitor);
&lt;/script&gt;</code></pre>
        </div>
    </div>

    <h4>5.2 Multiple Tables on Same Page</h4>
    <div class="code-example">
        <div class="header">Monitoring Multiple Tables on One Page</div>
        <div class="content">
            <pre><code>&lt;script&gt;
// Configuration for multiple tables
const TABLES_CONFIG = {
    tables: ['items', 'conductors', 'orders'],
    serverUrl: 'wss://your-domain.com/websocket'
};

let socket = null;
let tableData = {};

function initMultiTableMonitor() {
    socket = new WebSocket(TABLES_CONFIG.serverUrl);
    
    socket.onopen = function() {
        // Subscribe to all configured tables
        TABLES_CONFIG.tables.forEach(tableName =&gt; {
            socket.send(JSON.stringify({
                action: 'subscribe',
                table: tableName
            }));
        });
    };
    
    socket.onmessage = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.action === 'table_changed') {
            tableData[data.table] = data.data;
            updateTableDisplay(data.table, data.data);
        }
    };
}

function updateTableDisplay(tableName, data) {
    // Update specific table display based on table name
    const container = document.getElementById(`${tableName}-table`);
    if (container) {
        // Update the specific table's display
        container.innerHTML = generateTableHTML(data);
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', initMultiTableMonitor);
&lt;/script&gt;</code></pre>
        </div>
    </div>

    <h3>Step 6: Creating CRUD Operations for Your Table</h3>
    
    <h4>6.1 Backend CRUD Operations</h4>
    <div class="code-example">
        <div class="header">Adding CRUD Operations for Custom Tables</div>
        <div class="content">
            <pre><code>&lt;?php
// database_operations.php - Add your table operations
require_once('config.php');

header('Content-Type: application/json');

$input = json_decode(file_get_contents('php://input'), true);
$action = $input['action'] ?? '';

try {
    $pdo = getPDO();
    
    switch ($action) {
        case 'add_conductor':
            $name = $input['data']['name'] ?? '';
            $type = $input['data']['type'] ?? '';
            $size = $input['data']['size'] ?? '';
            $material = $input['data']['material'] ?? '';
            $resistance = $input['data']['resistance'] ?? 0;
            
            $query = "INSERT INTO conductors (name, type, size, material, resistance, created_at, updated_at) 
                     VALUES (?, ?, ?, ?, ?, GETDATE(), GETDATE())";
            $sql = $pdo->prepare($query);
            $result = $sql->execute([$name, $type, $size, $material, $resistance]);
            
            if ($result) {
                echo json_encode([
                    'success' => true,
                    'message' => 'Conductor added successfully'
                ]);
            } else {
                echo json_encode([
                    'success' => false,
                    'error' => 'Failed to add conductor'
                ]);
            }
            break;
            
        // Add other CRUD operations as needed...
    }
    
} catch (Exception $e) {
    echo json_encode([
        'success' => false,
        'error' => 'Database error: ' . $e->getMessage()
    ]);
}
?&gt;</code></pre>
        </div>
    </div>

    <h4>6.2 Frontend CRUD Integration</h4>
    <div class="code-example">
        <div class="header">Frontend CRUD with Real-time Updates</div>
        <div class="content">
            <pre><code>// CRUD Operations for Conductors
class ConductorsManager {
    constructor(tableConfig) {
        this.tableConfig = tableConfig;
        this.conductors = [];
    }

    async addConductor(conductorData) {
        try {
            const response = await fetch('database_operations.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'add_conductor',
                    data: conductorData
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Conductor added successfully');
                // WebSocket will automatically send updated data
                // No need to manually refresh
            } else {
                console.error('Failed to add conductor:', result.error);
            }
            
            return result;
        } catch (error) {
            console.error('Network error:', error);
            return { success: false, error: error.message };
        }
    }

    // Add other CRUD methods...
}

// Usage
const conductorsManager = new ConductorsManager({
    targetTable: 'conductors',
    serverUrl: 'wss://your-domain.com/websocket'
});

// Example: Add a new conductor
async function addNewConductor() {
    const conductorData = {
        name: 'Conductor-004',
        type: 'Power',
        size: '2/0 AWG',
        material: 'Copper',
        resistance: 0.0002
    };
    
    await conductorsManager.addConductor(conductorData);
    // UI will automatically update via WebSocket
}</code></pre>
        </div>
    </div>

    <h3>Step 7: Best Practices for Client-Specific Implementation</h3>
    
    <div class="warning">
        <strong>Important Considerations:</strong>
        <ul>
            <li><strong>Table Validation:</strong> Server validates table existence before subscription</li>
            <li><strong>Memory Efficiency:</strong> Server only monitors tables with active subscribers</li>
            <li><strong>Client Configuration:</strong> Each client should have clear, documented table configuration</li>
            <li><strong>Error Handling:</strong> Handle cases where configured table doesn't exist</li>
            <li><strong>Reconnection:</strong> Implement automatic resubscription on reconnection</li>
        </ul>
    </div>

    <h4>7.1 Recommended Client Structure</h4>
    <div class="code-example">
        <div class="header">Standard Client Structure</div>
        <div class="content">
            <pre><code>// Standard client structure
const CLIENT_CONFIG = {
    name: 'YourClientName',
    targetTable: 'your_table_name',
    serverUrl: 'wss://your-domain.com/websocket',
    autoReconnect: true,
    reconnectAttempts: 5
};

class TableMonitorClient {
    constructor(config) {
        this.config = config;
        this.socket = null;
        this.isConnected = false;
    }

    connect() {
        this.socket = new WebSocket(this.config.serverUrl);
        
        this.socket.onopen = () =&gt; {
            this.isConnected = true;
            this.subscribeToTable();
        };
        
        this.socket.onclose = () =&gt; {
            this.isConnected = false;
            if (this.config.autoReconnect && this.reconnectAttempts < this.config.reconnectAttempts) {
                this.scheduleReconnect();
            }
        };
        
        this.socket.onmessage = (msg) =&gt; {
            this.handleMessage(JSON.parse(msg.data));
        };
    }

    subscribeToTable() {
        if (this.isConnected) {
            this.socket.send(JSON.stringify({
                action: 'subscribe',
                table: this.config.targetTable
            }));
        }
    }

    handleMessage(data) {
        switch(data.action) {
            case 'table_changed':
                if (data.table === this.config.targetTable) {
                    this.onTableUpdate(data.data);
                }
                break;
            case 'error':
                console.error('Server error:', data.message);
                break;
        }
    }

    onTableUpdate(data) {
        // Override this method in your implementation
        console.log('Table updated:', data);
    }

    scheduleReconnect() {
        this.reconnectAttempts++;
        const delay = 1000 * Math.pow(2, this.reconnectAttempts - 1);
        setTimeout(() =&gt; this.connect(), delay);
    }
}

// Usage
const client = new TableMonitorClient(CLIENT_CONFIG);
client.onTableUpdate = (data) =&gt; {
    // Your custom update logic here
    updateYourUI(data);
};
client.connect();</code></pre>
        </div>
    </div>

    <h3>Step 8: Testing Your Client-Specific Implementation</h3>
    
    <div class="step">
        <strong>Testing Checklist:</strong>
        <ol>
            <li>Create your custom table in the database</li>
            <li>Configure your client with the correct table name</li>
            <li>Start the WebSocket server</li>
            <li>Open your client and verify connection</li>
            <li>Test real-time updates by modifying data in the database</li>
            <li>Test CRUD operations and verify WebSocket updates</li>
            <li>Test multiple clients monitoring different tables</li>
            <li>Test error scenarios (invalid table names, disconnections)</li>
        </ol>
    </div>

    <h4>8.1 Testing Multiple Clients</h4>
    <div class="code-example">
        <div class="header">Testing Script for Multiple Clients</div>
        <div class="content">
            <pre><code>&lt;?php
// test_multiple_clients.php
require_once('config.php');

echo "Testing multiple client scenarios...\n";

try {
    $pdo = getPDO();
    
    // Test 1: Create test tables
    $tables = ['items', 'conductors'];
    foreach ($tables as $table) {
        $query = "SELECT COUNT(*) as count FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ?";
        $sql = $pdo->prepare($query);
        $sql->execute([$table]);
        $result = $sql->fetch(PDO::FETCH_ASSOC);
        
        if ($result['count'] > 0) {
            echo "✓ Table '{$table}' exists\n";
        } else {
            echo "✗ Table '{$table}' not found\n";
        }
    }
    
    // Test 2: Insert test data
    $testData = [
        'items' => ['name' => 'Test Item', 'description' => 'Test Description'],
        'conductors' => ['name' => 'Test Conductor', 'type' => 'Test Type']
    ];
    
    foreach ($testData as $table => $data) {
        $columns = implode(', ', array_keys($data));
        $placeholders = implode(', ', array_fill(0, count($data), '?'));
        $query = "INSERT INTO {$table} ({$columns}) VALUES ({$placeholders})";
        $sql = $pdo->prepare($query);
        $result = $sql->execute(array_values($data));
        
        if ($result) {
            echo "✓ Test data inserted into '{$table}'\n";
        } else {
            echo "✗ Failed to insert test data into '{$table}'\n";
        }
    }
    
    echo "Multiple client test completed!\n";
    echo "Now test with Client1.php and Client2.php\n";
    
} catch (Exception $e) {
    echo "✗ Test failed: " . $e->getMessage() . "\n";
    exit(1);
}
?&gt;</code></pre>
        </div>
    </div>

    <h2>Real-Time Database Monitoring Integration</h2>
    
    <div class="info">
        <strong>Integration Guide:</strong> This section shows how to integrate real-time database monitoring into your own applications. The WebSocket system provides a foundation for listening to database changes and updating your UI accordingly.
    </div>

    <h3>Understanding the Real-Time Update Flow</h3>
    <p>The system works by monitoring database tables and broadcasting changes to all connected clients:</p>
    
    <div class="flow-diagram">
        <div class="step">
            <strong>Step 1:</strong> Database is modified (through your application's normal operations)
        </div>
        <div class="arrow">↓</div>
        <div class="step">
            <strong>Step 2:</strong> WebSocket server detects change via polling
        </div>
        <div class="arrow">↓</div>
        <div class="step">
            <strong>Step 3:</strong> Server broadcasts update to all subscribed clients
        </div>
        <div class="arrow">↓</div>
        <div class="step">
            <strong>Step 4:</strong> Your application receives real-time update
        </div>
    </div>

    <h3>Integrating WebSocket Listening into Your Application</h3>
    <p>To add real-time database monitoring to your application:</p>
    
    <div class="feature-list">
        <div class="feature">
            <h4>📊 Basic Integration Steps</h4>
            <ul>
                <li><strong>Connect to WebSocket:</strong> Establish connection to the WebSocket server</li>
                <li><strong>Subscribe to Tables:</strong> Tell the server which tables you want to monitor</li>
                <li><strong>Handle Updates:</strong> Process incoming real-time data updates</li>
                <li><strong>Update UI:</strong> Reflect changes in your application interface</li>
            </ul>
        </div>
        
        <div class="feature">
            <h4>⚡ Advanced Integration Features</h4>
            <ul>
                <li><strong>Multiple Table Monitoring:</strong> Subscribe to multiple tables simultaneously</li>
                <li><strong>Error Handling:</strong> Implement reconnection logic and error recovery</li>
                <li><strong>Custom UI Updates:</strong> Design your own interface for displaying real-time data</li>
                <li><strong>Performance Optimization:</strong> Efficiently handle frequent updates</li>
            </ul>
        </div>
    </div>

    <h3>Client-Side Implementation Example</h3>
    <div class="code-example">
        <div class="header">Basic WebSocket Integration</div>
        <div class="content">
            <pre><code>// Basic WebSocket client for your application
class DatabaseMonitor {
    constructor(serverUrl, targetTable) {
        this.serverUrl = serverUrl;
        this.targetTable = targetTable;
        this.socket = null;
        this.isConnected = false;
        this.onDataUpdate = null; // Callback for data updates
    }

    connect() {
        this.socket = new WebSocket(this.serverUrl);
        
        this.socket.onopen = () => {
            this.isConnected = true;
            console.log('Connected to database monitor');
            this.subscribeToTable();
        };
        
        this.socket.onmessage = (msg) => {
            const data = JSON.parse(msg.data);
            this.handleMessage(data);
        };
        
        this.socket.onclose = () => {
            this.isConnected = false;
            console.log('Disconnected from database monitor');
        };
    }

    subscribeToTable() {
        if (this.isConnected) {
            this.socket.send(JSON.stringify({
                action: 'subscribe',
                table: this.targetTable
            }));
        }
    }

    handleMessage(data) {
        switch(data.action) {
            case 'table_changed':
                if (data.table === this.targetTable) {
                    // Call your custom update function
                    if (this.onDataUpdate) {
                        this.onDataUpdate(data.data);
                    }
                }
                break;
        }
    }

    // Set callback for data updates
    setUpdateCallback(callback) {
        this.onDataUpdate = callback;
    }
}

// Usage in your application
const monitor = new DatabaseMonitor('wss://your-domain/websocket', 'your_table_name');

// Define how to handle updates
monitor.setUpdateCallback((data) => {
    // Update your application's UI here
    updateYourApplicationUI(data);
});

// Connect to start monitoring
monitor.connect();</code></pre>
        </div>
    </div>

    <h3>Integration Best Practices</h3>
    
    <div class="info">
        <strong>Key Integration Points:</strong>
        <ul>
            <li><strong>Connection Management:</strong> Implement proper reconnection logic for production use</li>
            <li><strong>Error Handling:</strong> Handle network errors and server disconnections gracefully</li>
            <li><strong>UI Updates:</strong> Design efficient ways to update your interface with real-time data</li>
            <li><strong>Performance:</strong> Consider throttling updates for high-frequency changes</li>
            <li><strong>Security:</strong> Implement authentication if needed for your use case</li>
        </ul>
    </div>

    <h3>Testing Your Integration</h3>
    
    <div class="step">
        <strong>Testing Checklist:</strong>
        <ol>
            <li><strong>Connection Test:</strong> Verify WebSocket connection establishes successfully</li>
            <li><strong>Subscription Test:</strong> Confirm table subscription works</li>
            <li><strong>Update Test:</strong> Modify database and verify real-time updates</li>
            <li><strong>UI Update Test:</strong> Ensure your application UI updates correctly</li>
            <li><strong>Error Handling Test:</strong> Test disconnection and reconnection scenarios</li>
            <li><strong>Performance Test:</strong> Verify system handles your expected update frequency</li>
        </ol>
    </div>

    <h3>Extending for Your Use Case</h3>
    <p>To adapt this system for your specific needs:</p>
    
    <ol>
        <li><strong>Identify Your Tables:</strong> Determine which database tables you need to monitor</li>
        <li><strong>Design Your UI:</strong> Create interfaces for displaying your real-time data</li>
        <li><strong>Implement Update Logic:</strong> Write code to handle incoming data updates</li>
        <li><strong>Add Error Handling:</strong> Implement robust error handling for production use</li>
        <li><strong>Test Thoroughly:</strong> Verify everything works with your actual database</li>
    </ol>

    <div class="highlight">
        <strong>Important:</strong> This WebSocket system provides the real-time monitoring foundation. You're responsible for implementing your own database operations (inserts, updates, deletes) and designing your application's user interface.
    </div>

    <h2>Deployment & Configuration</h2>
    <h3>WebSocket Proxy Setup</h3>
    <p>The system uses Apache's reverse proxy to handle WSS (WebSocket Secure) connections:</p>
    <pre><code># .htaccess configuration
RewriteEngine On
RewriteCond %{HTTP:Upgrade} websocket [NC]
RewriteCond %{HTTP:Connection} upgrade [NC]
RewriteRule websocket$ ws://127.0.0.1:9000/ [P,L]
</code></pre>
    <p>This allows clients to connect via <code>wss://</code> while the backend server runs on plain <code>ws://</code>.</p>

    <h3>Server Startup</h3>
    <ul>
        <li>Start the WebSocket server: <code>php server.php</code></li>
        <li>Ensure your database is accessible and configured in <code>config.php</code></li>
        <li>Server will automatically discover all tables on startup</li>
        <li>Clients can connect via WebSocket to <code>wss://your-domain/websocket</code></li>
        <li>For production, consider using a process manager like Supervisor or PM2</li>
    </ul>

    <h2>Use Cases & Scenarios</h2>
    <div class="info">
        <strong>Multi-Client Scenarios:</strong>
        <ul>
            <li><strong>Dashboard A:</strong> Subscribes to <code>orders</code>, <code>customers</code> tables</li>
            <li><strong>Dashboard B:</strong> Subscribes to <code>inventory</code>, <code>products</code> tables</li>
            <li><strong>Admin Panel:</strong> Subscribes to <code>users</code>, <code>logs</code> tables</li>
            <li><strong>Analytics:</strong> Subscribes to <code>sales</code>, <code>metrics</code> tables</li>
        </ul>
    </div>

    <h2>Performance Considerations</h2>
    <ul>
        <li><strong>Polling Interval:</strong> Adjust <code>$monitorInterval</code> based on your needs (2 seconds default)</li>
        <li><strong>Table Selection:</strong> Only tables with active subscribers are monitored</li>
        <li><strong>Hash Comparison:</strong> Uses MD5 hashes to detect changes efficiently</li>
        <li><strong>Targeted Broadcasting:</strong> Updates only sent to interested clients</li>
        <li><strong>Connection Management:</strong> Automatic cleanup of disconnected clients</li>
    </ul>

    <h2>Best Practices</h2>
    <ul>
        <li><strong>Error Handling:</strong> Always wrap database operations in try-catch blocks</li>
        <li><strong>Connection Management:</strong> Implement proper reconnection logic on the client</li>
        <li><strong>Security:</strong> Validate all incoming messages and implement authentication if needed</li>
        <li><strong>Performance:</strong> Adjust the polling interval based on your needs</li>
        <li><strong>Logging:</strong> Use the callback system to log important events</li>
        <li><strong>Table Management:</strong> Consider table permissions and access control</li>
    </ul>

    <div class="highlight">
        <strong>Remember:</strong> This is a scalable, table-agnostic foundation. You're responsible for:
        <ul>
            <li>Your own database operations</li>
            <li>Business logic and validation</li>
            <li>Authentication and authorization</li>
            <li>Error handling and logging</li>
            <li>Table-specific access control</li>
        </ul>
    </div>

    <hr>
    <p>For more details, see the source code files. This system is designed to be scalable, flexible, and focused on efficient multi-table monitoring.</p>
</body>
</html> 